#include<iostream>
using namespace std;
class S {
	public:
		S();
		S(int);
		S(const S &);
		~S() {
			cout<<"delete R."<<endl ;
		};
		void setR(int);
		int getR() const ;
	private:
		int *R;
};
S::S() {
	R=new int(5);
}
S::S(int r) {
	R=new int(r);
}
S::S(const S &c) {
	int v=c.getR();
	R=new int(v);
}
int S::getR() const {
	return *R;
}
int main() {
	S S1,S2(9);
	cout<<"1:"<<S1.getR()<<endl;
	cout<<"2:"<<S2. getR()<<endl;
	S1.~S();//析构函数不能释放对象，因为在调用某对象的析构函数后还能访问此对象。
	//构造函数和析构函数只是系统留给编程者在对象构建和析构时，能插入代码的函数，且该函数在系统操作之前执行 
	//程序中定义的类对象，是由系统释放的而不是析构函数释放的。这就是调用析构函数并不能释放对象原因
	//举个例子，默认的析构函数也是空的，如果是析构函数释放对象的话，那默认为空的析构函数怎么释放对象
	//对象的释放不是由析构函数释放的，是系统自动释放的。但对程序中不能自动释放的内容，就需要编程者在析构函数中释放了
	//比如对于编程者用new申请的内存，系统是不会自动释放的，所以这时就需要编程者在析构函数中主动释放掉，否则就造成了内存泄漏 
	//所以，析构函数的机制是在这个时机，给编程者一个执行代码的机会，把需要编程者释放的内容放到析构函数中释放 
	cout<<"1:"<<S1. getR()<<endl;
	cout<<"111"<<endl;
	return 0;
}
//系统因为在编译时是无法知道运行时指针所指申请的内存大小，所以不能自动释放指针所指的内存 
//另因为指针本身是变量，在运行时也可以动态变动，所以编译器无法检查所指是否超界。所以指针的灵活性，也伴随着隐藏的危险性。
//同时因为指针可以轻松指向他不该指的地方，所以指针的概念也破坏了面向对象的封装。
 
