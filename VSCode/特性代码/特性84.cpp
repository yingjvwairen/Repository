#include<iostream>
using namespace std;
 class B {
	public:
		int m_iNum;
		virtual void foo();
};

class D:
	public B {
	public:
		char* m_szName[100];
};

void func(B* pb) {
	D* pd1=static_cast<D*>(pb);
	D* pd2=dynamic_cast<D*>(pb);
}
/*
在上面的代码段中，如果 pb 指向一个 D 类型的对象，pd1 和 pd2 是一样的，并且对这两个指针执行 D 类型的任何操作都是安全的；
但是，如果 pb 指向的是一个 B 类型的对象，那么 pd1 将是一个指向该对象的指针，对它进行 D 类型的操作将是不安全的（如访问 m_szName），而 pd2 将是一个空指针。
另外要注意：B 要有虚函数，否则会编译出错；static_cast则没有这个限制。
这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见<Inside c++ object model>）中，只有定义了虚函数的类才有虚函数表，没有定义虚函数的类是没有虚函数表的。
*/ 
int main()
{
}
/*
在C++的面对对象思想中，虚函数起到了很关键的作用，
当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，
假如继承该类的子类定义并实现了一个同名并具有同样函数签名（function siguature）的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。
此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。
当然虚函数表的存在对于效率上会有一定的影响，首先构建虚函数表需要时间，根据虚函数表寻到到函数也需要时间。
因为这个原因如果没有继承的需要，一般不必在类中定义虚函数。但是对于继承来说，虚函数就变得很重要了，这不仅仅是实现多态性的一个重要标志，同时也是dynamic_cast转换能够进行的前提条件。
比如去掉上面例子中B类中的虚函数，那么语句
　　D* pd2=dynamic_cast<D*>(pb);
在编译期就会直接报出错误，具体原因不是很清楚，可能是因为当类没有虚函数表的时候，dynamic_cast就不能用RTTI来确定类的具体类型，于是就直接不通过编译。
这不仅仅是没有继承关系的类之间的情况，如果基类或者子类没有任何虚函数（如果基类有虚函数表，子类当然是自动继承了该表），当他们作为dynamic_cast的源类型进行转换时，编译也会失败。
这种情况是有可能存在的，因为在设计的时候，我们可能不需要让子类重写任何基类的方法。但实际上，这是不合理的。
在多态性中，如果要用继承，那么最好要让析构函数是虚函数；如果一个函数是虚函数，那么在子类中最好也要是虚函数。
*/ 
