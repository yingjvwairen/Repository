/*

 尼：C械o元 中的芯片合成规律

+0级芯片最小COST为4

+1级芯片最小COST为5  X=(a+b)*0.5+1 舍 小数取整 举例：4+4=5 4+5=5

+2级芯片最小COST为6  X=(a+b)*0.5+1 舍 小数取整 举例：5+5=6 5+6=6

+3级芯片最小COST为7  X=(a+b)*0.5+1 进 小数取整 举例：6+6=7 6+7=8

+4级芯片最小COST为9  X=(a+b)*0.5+2 舍 小数取整 举例：7+7=9 7+8=9

+5级芯片最小COST为11 X=(a+b)*0.5+2 进 小数取整 举例：9+9=11 9+10=12

+6级芯片最小COST为14 X=(a+b)*0.5+3 舍 小数取整 举例：11+11=14 11+12=14

+7级芯片最小COST为17 X=(a+b)*0.5+3 进 小数取整 举例：14+14=17 14+15=18

+8级芯片最小COST为21 X=(a+b)*0.5+4 舍 小数取整 举例：17+17=21 17+18=21

X表示合出来芯片的总COST，a、b表示用于合成的两枚芯片COST，(a+b)*0.5代表从上一等级中继承下来的COST，而+号后代表提升等级时此等级固定增加的COST

*/

/*

这里提供三种简单易记的方法来实现 NieR:Automata 中的芯片合成的内在规律：

三种方法中的+0级芯片最小COST均设为4

第一种方法：+2的n次方级的芯片合成时均为舍小数取整（n从0开始，其余为进小数取整。每一等级芯片固定增加的COST为此等级的一半且进舍小数的情况与此等级继承COST进舍小数的情况相反

第二种方法：从1开始，每乘以2所得到等级的芯片合成时均为舍小数取整，其余为进小数取整。每级固定增加的COST为等级的一半且进舍小数的情况与此等级继承COST进舍小数的情况相反

第三种方法：除了合成+1的芯片以外，合成其他的芯片时继承COST遵循偶数舍，奇数进的规律，且芯片等级额外固定增加的COST为等级值除二舍小数取整（原理是整数无论是用去尾法还是进一法取整结果都一样

***但是第三种方法的原理在计算机中是不自然的，因为在计算机的运算中，进一法的实现一般是两数相除后加一，而如果考虑到一般性，当两数相除后结果为整数时，运算时也会在结果后加一，此时就会与进一法的规定相悖

***再进一步想，当一个表达式中进一法与去尾法同时存在时，原则上虽然不能互换，但在计算机中的实现表达式其实是可以交换的，所以可将+1级芯片的舍小数取整换为进小数取整，将固定增加的COST换为舍小数取整

***即可得到通式：当两数不相等时，奇数为X=(a+b)*0.5+等级数/2+1，偶数为X=(a+b)*0.5+等级数/2

*/
#include<iostream>
#include<cmath>
using namespace std;
int main() {
	int COST,cost,Level;
//第一种方法
	for(int n=0; n<4; ++n)
		if(Level==pow(2,n)) {
			COST=(COST+cost)/2,
			cout<<COST;
			return 0;
		}
	cout<<(COST+cost)/2+1;
	return 0;
//第二种方法
	for(int n=1; n<=8; n<<2)
		if(Level==n) {
			COST=(COST+cost)/2,
			cout<<COST;
			return 0;
		}
	cout<<(COST+cost)/2+1;
	return 0;
//第三种方法
	if(Level==1) {
		COST=(COST+cost)/2+Level/2+1,
		cout<<COST;
		return 0;
	}
	for(int n=2; n!=16; n*=2)
		if(Level==n) {
			COST=(COST+cost)/2+Level/2,
			cout<<COST;
			return 0;
		}
	cout<<(COST+cost)/2+1+Level/2;
	return 0;
//拓展：通式   适用于两数不相等时的情况   奇数：(COST+cost)/2+Level/2+1 偶数：(COST+cost)/2+Level/2
	if(!Level%2)
		cout<<(COST+cost)/2+Level/2+1;
	else
		cout<<(COST+cost)/2+Level/2;
}

