#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std; 
int main()
{
	char str[1024];
	gets(str);
	//puts(str);
	for(int i=0;i<=sizeof(str);++i)
	{	
		printf("%d\n",str[i]);//注意字母（大写所对应的ASCII编码和其所对应数字的编码相差55 
		if(!str[i])
		{
			printf("是");
			cout << endl;
			break;
		}
	}	
	cout << sizeof(*str) << "\n"; 
	cout << sizeof(*str+1) << '\n';
		/*关于由1变为4的猜想(C++：
str代表了str[0]?即字符数组的首地址，则*str代表了str[0]中所存放的数据(字符型
执行*str+1时，因*str为字符型变量，而此时1被编译器默认视为整型变量
	(因为只有数值型或字符串型变量才能相加减，但这里的1并没有加上""(即双引号，所以编译器不会将1视做是字符串常量。故编译器会将*str的类型隐式转换为默认的整型，后再加1(此时会创建临时变量
	最后sizeof整型数据自然就是4了。。。
执行sizeof()时，如上所述的话应该是检测的临时变量的内存空间，但临时变量会在完整表达式执行完毕后析构释放，所以可以引出基于假设的推论：
sizeof()中产生的变量类型隐式转换并不被算做是一个完整表达式，只有在sizeof执行结束后才算完整表达式过程的结束，将之推广即得变量类型转换并不被算做是一个完整表达式
而由此例可注意到：
临时变量可以保证原始数据不被更改，以加深对临时变量的作用的体会与理解。(类似于数据互相交换时为中间变量定义的作用(定义变量的本质其实就是给变量分配内存空间*/
}

 
