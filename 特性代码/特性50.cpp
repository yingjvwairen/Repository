
# include <iostream> 
 
using namespace std;

int main ()

{

/*

测试 二维数组 数组名和整个数组地址、首行地址、首行首地址的区别和联系

*/


	//一维数组地址分析

	char b[30] = { "wxyz" };

	//&b 代表的是整个一维数组的首地址，+1 表示跳过整个一维数组 步长=1*30 = 30。

	//相当于二维数组的数组名a 代表的数组首行地址 a+1 步长是整个一维数组的长度。

	// *a 等价于 *(&b) b也就是数组首个元素的地址，所以*a +1是跳过一个元素。

	printf("&b=%d,&b+1=%d\n", &b, &b + 1);

 

	//b 也就是一维数组名 代表首元素地址，+1 跳过一个元素 步长=1*1=1

	printf("b=%d,b+1=%d\n",b,b+1);

 

	//知道b是首元素地址，那么*b就是首元素的内容了*(b+1)也就是第二个元素的内容了。

	printf("*b=%c,*(b+1)=%c\n", *b, *(b + 1));

 	

	 


	char a[4][30] = { "abcd","efjh","ijkl","mnop" };

	//&a 代表的是数组首地址，+1 步长=4*30*1 = 120

	printf("&a=%d,&a+1=%d\n", &a, &a + 1);

 

	//a 也就是数组名 代表的是数组首行地址，+1 跳过一行 步长=1*30*1=30

	printf("a=%d,a+1=%d\n",a,a+1);

 

	//a 是首行地址 步长是整个一维数组，也是整个一维数组的首地址 。(*一维数组首地址) 就是首元素地址

	//*a 就是首行首元素地址，+1 跳过一个元素 步长 = 1*1 

	printf("*a=%d,*a+1=%d\n", *a, *a + 1);

 

	//尽管 整个二维数组地址、首行地址、首行首元素地址他们的值是一样的，但是他们本质不一样，也就是+1代表的步长不一样！

	printf("整个二维数组地址：%d,首行地址：%d,首行首元素地址：%d\n",&a,a,*a);

 

	//我们知道*a代表二维数组首行首元素地址，那么**a 也就是首行首元素的内容了！

	//*(*a+0)：第一个元素内容，*(*a+1)：第二个元素内容,*(*a+30)：第二行第一个元素内容，*(*a+31)：第二行第二个元素内容。

	printf("**a：%c,*(*a+1)：%c,*(*a+30)：%c,*(*a+31):%c\n", *(*a + 0), *(*a + 1), *(*a + 30), *(*a + 31));

	//当然我们取第二行元素的内容，同样可以使用第二行行地址来取。

	//a+1代表第二行地址，*(a+1)：第二行首元素地址，*(a+1)+1：第二行第二个元素地址，知道地址就可以用*取出内容。

	//*(*(a+1))：第二行第一个元素内容,*(*(a+1)+1):第二行第二个元素内容。和上面取出来一样，从侧面也验证了二维数组在内存中还是线性存储的。

	printf("*(*(a+1))：%c,*(*(a+1)+1):%c\n", *(*(a + 1)), *(*(a + 1) + 1));

 


	//三维数组或者更多维的数组都是一样的，我们只需要把数组名当做变量最近的那个[]方括号里面内容的地址就行了。


}
