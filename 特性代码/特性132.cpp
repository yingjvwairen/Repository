#include <iostream>

using namespace std;

class vircla{
   public:
   vircla(){};//构造函数不能是虚函数，因为类还未被构造完成，多态是disable的。也正因为如此，在构造函数中调用虚函数，实际运行的是父类的相应函数
   virtual ~vircla()=0;//析构函数能够是纯虚的，也可以给出定义体。声明一个纯虚析构函数的目的一般是为了将此类定义成抽象类，让之不能实例化对象
   virtual void test()=0;
};

vircla::~vircla(){}

void vircla::test(){cout << "circla";}//纯虚函数通常未定义函数体，但也全然能够拥有，也能够显式调用
//所以，将一个函数定义为纯虚函数，实际上是将这个类定义为抽象类，不能实例化对象
//因为非纯的虚函数必须有定义体，不然是一个错误。所以对于暂且无法实现的函数，定义为纯虚函数留给派生类实现可以防止报错

/*
定义纯虚函数的真正目的一般是为了定义抽象类，而并非函数本身。与之对照，在JAVA中，定义抽象类的语法是 abstract class，也就是在类一级指定
是不是这样的方式更好一些呢？在《C++语言的设计与演化》一书中有这样一段话：
我选择的是将个别的函数描写叙述为纯虚的方式，没有采用将完整的类声明定义为抽象的形式，这是由于纯虚函数的概念更加灵活一些
我非常看重能够分阶段定义类的能力，也就是说，我发现预先定义一些纯虚函数，并把另外一些留给进一步的派生类去定义也是非常实用的
*/

class derived:public vircla{
   public:
   void test(){cout << "derived";}
};

int main()
{
   vircla *dc=(vircla*) new derived;//不允许强制转换到抽象类，但可以强制转换到抽象类的指针或引用
   vircla &vc=*dc;//引用变量需要初始值设定项
   dc->test();
   vc.test();
   delete dc;
}
